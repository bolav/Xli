#!/bin/sh
set -e

case $1 in 
clean)
    DO_CLEAN=1
    shift
    ;;
install)
    DO_INSTALL=1
    shift
    ;;
esac

while [ $# -gt 0 ]; do
    OPT=$1

    case $OPT in
    -j*|-D*|-U*)
        if [ -z ${OPT:2} ]; then
            shift
            OPT="$OPT$1"
        fi
        ;;
    esac

    case $OPT in 
    -h|-\?|--help)
        cat <<E0
Usage: cmakemake [<build-options>] <project-dir>
  or   cmakemake install [--debug] <project-dir>
  or   cmakemake clean <project-dir>

Build options:

  --debug             Debug build
  --release           Release build (default)
  --target="xcode"    Generate and build Xcode project
  --no-build          Generate project, but don't build
  --prefix=<path>     Set install prefix
  -j<cpu-count>       Set compiler job count
  -D<variable=value>  Define a cmake variable
  -U<variable>        Undefine a cmake variable

Build script for CMake projects.

This command wraps 'cmake && make' with some additional features:
  - Optimized release build by default, unless --debug or DEBUG=1
  - Out of source builds with debug and release built to separate folders
  - Paralell builds out of the box
  - Xcode batch builds (OS X only)
  - MSYS builds (Windows only)

Additional arguments to cmake can be passed using environment variable CMAKE_ARGS.
E0
        exit 1
        ;;
    --debug)
        DEBUG=1
        ;;
    --release)
        DEBUG=0
        ;;
    --no-build)
        DO_BUILD=0
        ;;
    --target=*)
        TARGET="${OPT:9}"
        ;;
    --prefix=*)
        CMAKE_ARGS="$CMAKE_ARGS -DCMAKE_INSTALL_PREFIX:PATH=${OPT:9}"
        ;;
    -j*)
        JOB_COUNT="${OPT:2}"
        ;;
    -D*)
        CMAKE_ARGS="$CMAKE_ARGS -D${OPT:2}"
        ;;
    -U*)
        CMAKE_ARGS="$CMAKE_ARGS -U${OPT:2}"
        ;;
    --)
        shift
        break
        ;;
    *)
        if [ $# -eq 1 ]; then
            break
        else
            echo "ERROR: Unable to parse arguments '$@'\n\nType \`cmakemake --help\` for usage." >&2
            exit 1
        fi
        ;;
    esac

    shift
done

PROJECT_DIR="$@"

#echo "'$DO_INSTALL' '$DO_CLEAN' '$DO_BUILD' '$DEBUG' '$TARGET' '$JOB_COUNT' '$CMAKE_ARGS' '$PROJECT_DIR'" && exit 1

if [ -z "$PROJECT_DIR" ]; then
    echo "ERROR: No project directory specified.\n\nType \`cmakemake --help\` for usage." >&2
    exit 1
fi

cd "$PROJECT_DIR"

if [ "$DO_CLEAN" = "1" ]; then
    for dir in "build/cmake-release" "build/cmake-debug"; do
        if [ -f "$dir/Makefile" ]; then
            cd "$dir"
            make clean
            cd "$OLDPWD"
        fi
    done

    rm -rfv build/cmake-*
    exit 0
fi

if [ "$DEBUG" = "1" ]; then
    BUILD_DIR="build/cmake-debug"
    CMAKE_ARGS="$CMAKE_ARGS -DCMAKE_BUILD_TYPE:STRING=Debug"
else
    BUILD_DIR="build/cmake-release"
    CMAKE_ARGS="$CMAKE_ARGS -DCMAKE_BUILD_TYPE:STRING=Release"
fi

if [ "$DO_INSTALL" = "1" ]; then
    cd "$BUILD_DIR"
    make install
    exit 0
fi

if ! which cmake > /dev/null 2>&1; then
    # This is sometimes needed when run from GUI applications on OS X
    PATH=$PATH:/opt/local/bin

    if ! which cmake > /dev/null 2>&1; then
        echo "ERROR: Unable to find the \`cmake\` command. Make sure cmake is installed and added to \$PATH." >&2
        exit 1
    fi
fi

if [ -n "$TARGET" ]; then
    case $TARGET in
    xcode)
        mkdir -p build/cmake-xcode
        cd build/cmake-xcode

        cmake ../.. -GXcode $CMAKE_ARGS

        if [ "$DO_BUILD" != "0" ]; then
            if [ -z "$DEBUG" ] || [ "$DEBUG" == "1" ]; then
                xcodebuild -alltargets -configuration Debug
            fi

            if [ -z "$DEBUG" ] || [ "$DEBUG" == "0" ]; then
                xcodebuild -alltargets -configuration Release
            fi
        fi

        exit 0
        ;;
    *)
        echo "ERROR: Invalid target '$TARGET'.\n\nType \`cmakemake --help\` for usage." >&2
        exit 1
        ;;
    esac
fi

if [ -z "$JOB_COUNT" ]; then
    if [ -f /proc/cpuinfo ]; then
        JOB_COUNT=`grep processor /proc/cpuinfo | wc -l`
    elif [ "`uname`" = "Darwin" ]; then
        JOB_COUNT=`sysctl hw.ncpu | cut -d " " -f 2`
    elif [ -n "$NUMBER_OF_PROCESSORS" ]; then
        JOB_COUNT=$NUMBER_OF_PROCESSORS
    else
        JOB_COUNT=1 
    fi
fi

mkdir -p "$BUILD_DIR"
cd "$BUILD_DIR"

#rm -f CMakeCache.txt

if [ "$OSTYPE" = "msys" ]; then
    export CMAKE_ARGS="$CMAKE_ARGS -G\"MSYS Makefiles"
    cmd "/C cmake ../.. %CMAKE_ARGS%"
else
    cmake ../.. $CMAKE_ARGS
fi

if [ "$DO_BUILD" != "0" ]; then
    make -j "$JOB_COUNT"
fi
